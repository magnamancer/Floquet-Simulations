# -*- coding: utf-8 -*-

import numpy.ma as ma
import numpy as np
from qutip import *
import itertools
import math
import scipy as scp

'''
This script contains 'lowest-level' definition functions that are called
    by many things in the mid-level functions and the top-level object 
    definitions
'''
################### Floquet mode and state solver Functions ############



def floquet_fourier_amps(Nt,tlist,bath_operator_list, floquet_modes_array, opts = None):
    '''
    

    Parameters
    ----------
    Nt : int
        Number of evenly space points in one time period of the Hamiltonian. Should probably be a power of 2.
    tlist : np.linspace
        List of Nt time points evenly distributed within one period T of the Hamiltonian
    bath_operator_list : list of collapse operator objects
        list of collapse operator objects, used to calculate the Fourier Amplitudes for each rate matrix
    floquet_modes_array : np.array
        Array of Floquet Modes, used to transform the collapse operators into the FLoquet Mode Basis
    opts : TYPE, optional
       optional arguments for solver. The default is None.

    Returns
    -------
    amplitude_list : list of numpy arrays
        List of Fourier amplitude matrices, one for each collapse operator

    '''
    amplitude_list = []
    for c_op in bath_operator_list:
        if opts == None:
            opts = Options()                                  #Setting up the options used in the mode and state solvers
            opts.atol = 1e-8                                  #Absolute tolerance
            opts.rtol = 1e-8                                  #Relative tolerance
            opts.nsteps= 10e+8                                #Maximum number of Steps                              #Maximum number of Steps
        
        
        Hdim = np.shape(c_op)[0]
        
        '''
        I'm going to keep this as its own method for now, as it might be nice
            to be able to pull graphs of the FFT of the lowering operators when
            desired.
            
            
        This function transforms the lowering operator into the Floquet mode basis
        '''
        
        floquet_modes_array_conjT = np.transpose(floquet_modes_array.conj(),(0,2,1) )
        
        c_op_Floquet_basis = (floquet_modes_array_conjT @ c_op @ floquet_modes_array)
                   
    
        
        '''
        Performing the 1-D FFT to find the Fourier amplitudes of this specific
            lowering operator in the Floquet basis
            
        Divided by the length of tlist for normalization
        '''
        
        c_op_Fourier_amplitudes = np.sum(scp.fft.fft(c_op_Floquet_basis,axis=0),axis=0)/(len(tlist))
        amplitude_list.append(c_op_Fourier_amplitudes)
        
     
    return amplitude_list





def floquet_rate_matrix(qe,fourier_amplitude_matrices_list,c_op_rates,beatfreq,time_sense=0):
    '''
    

    Parameters
    ----------
    qe : list
        List of Floquet quasienergies of the system.
    fourier_amplitude_matrices_list : list of 2D numpy arrays
        List of the collapse_operator Fourier amplitude matrices 
            generated by floquet_fourier_amps
    c_op_rates : list
        List of collapse operator rates/magnitudes.
    beatfreq : float
        the beating frequency of the system (or spoofed beating frequency
             in the monochromatic case)
    time_sense : float 0-1, optional
        the time sensitivity/secular approximation restriction for this rate
            matrix as a multiple of the system frequency beatfreq. As far as 
            Ned and I have guessed (cause we aren't positive),0 is completely 
            time independant and in line with, e.g. Blumel's R tensor 
            description (sure of this) and 1 is completely time dependant 
            (unsure of this). The default is 0.

    Returns
    -------
    total_R_tensor : 2D Numpy matrix
        This is the 2D rate matrix for the system, created by summing the 
            Rate matrix of each individual collapse operator. Something 
            something Rate Matrix something something linear Operator.
            

    '''
    Rate_matrix_list = []
    for cdx, c_op_amplitude_matrix in enumerate(fourier_amplitude_matrices_list):
        Hdim = len(qe)
        
        '''
        First, divide all quasienergies by omega to get everything in terms of omega. 
            This way, once I've figured out the result of the exponential term addition, 
            I can just multiply it all by w
            
        Defining the exponential sums in terms of w now to save space below
        '''
        def delta(a,ap,b,bp):
            return ((qe[a]-qe[ap]) - (qe[b]-qe[bp]))/(beatfreq/2)
        
        '''
        Next step is to create the R matrix from the "good" values of the indices
        Need to Condense these loop later with the functions Ned sent me in an email
        
        The loops over n,m,p,q are to set the n,m,p,q elements of the R matrix for a 
            given time dependence. The other loops are to do sums within those elements.
            The Full form of the FLime as written here can be found on the "Matrix Form 
            FLiME" OneNote page on my report tab. Too much to explain it here!
        
        '''
        
        '''
        Noteworthy for sum ordering purposes: itertools likes to iterate over the LAST thing first.
            E.g. if you iterated over all combinations of a list of 4 numbers from 0-3, it would go
            [0,0,0,0],[0,0,0,1],[0,0,0,2]...[0,0,1,0],[0,0,1,1],....[3,3,3,3]
        '''
        iterations_test_list = [Hdx for Hdx in itertools.product(range(0,Hdim),repeat = 4)]  #Iterating over all possible iterations of A,AP,B,BP
        
        '''
        From here on out, I'll be using the same indices for everything:
            
        alpha = var_name[0]
        alpha' = var_name[1]
        beta = var_name[2]
        beta' = var_name[3]
        '''
        
        
        #The asterisk is to unpack the tuple from iterations_test_list into arguments for the function
        time_dependence_list = [delta(*test_itx) for test_itx in iterations_test_list]
        
        valid_TDXs = (~ma.masked_where(np.absolute(time_dependence_list)>time_sense,time_dependence_list).mask).nonzero()[0] #Creates a list of the indices of the time dependence coefficient array whose entries are within the time dependence constraint time_sense
        
    
    
        valid_time_dependence_summation_index_values = [tuple(iterations_test_list[valid_index]) for valid_index in valid_TDXs] #creates a list tuples that are the valid (a,b,ap,bp,l,lp) indices to construct R(t) with the given secular constraint
    
        
        c_op_R_tensor = {} #Time to build R(t). Creating an empty dictionary.
        for vdx, vals in enumerate(valid_time_dependence_summation_index_values): #For every entry in the list of tuples, create R(t)
            a  = vals[0]
            ap = vals[1]
            b  = vals[2]
            bp = vals[3]
            
            R_slice = np.zeros((Hdim**2,Hdim**2),dtype = complex)  
            for idx in np.ndindex(Hdim,Hdim,Hdim,Hdim): #iterating over the indices of R_slice to set each value. Should figure out something faster later
                m = idx[0]
                n = idx[1]
                p = idx[2]
                q = idx[3]
                
                R_slice[m+Hdim*n,p+Hdim*q] =                                       \
                    c_op_rates[cdx]*c_op_amplitude_matrix[a,b]*np.conj(c_op_amplitude_matrix[ap,bp])*                          \
                                ( kron(m, a) * kron(n,ap) * kron(p,b) * kron(q,bp) \
                           -(1/2)*kron(a,ap) * kron(m,bp) * kron(p,b) * kron(q, n) \
                           -(1/2)*kron(a,ap) * kron(n, b) * kron(p,m) * kron(q,bp))
            
            try:
                c_op_R_tensor[time_dependence_list[valid_TDXs[vdx]]] += R_slice  #If this time-dependence entry already exists, add this "slice" to it
            except KeyError:
                c_op_R_tensor[time_dependence_list[valid_TDXs[vdx]]]  = R_slice   #If this time-dependence entry doesn't already exist, make it
    
        Rate_matrix_list.append(c_op_R_tensor)
        
        
    total_R_tensor = {}
    for Rdic_idx in Rate_matrix_list:
        for key in Rdic_idx:
            try:
                total_R_tensor[key] += Rdic_idx[key]  #If this time-dependence entry already exists, add this "slice" to it
            except KeyError:
                total_R_tensor[key]  = Rdic_idx[key]   #If this time-dependence entry doesn't already exist, make it
        
    
    return total_R_tensor

'''
Creating a function that takes the Rdictionary, multiples each key by its associated 
    time dependence, then adds everything up to get a single
    time-dependent R tensor for the ODE solver to solve

This function is defined seperately from the above so that the R tensor dictionary
    isn't reconstructed every time the ODE solver below calls the function!
'''
def rhodot(t,p,Rdic,beatfreq,):
    '''
    This function is only used to form the IVP for solve_ivp efficiently. If 
    you're not Fenton and you need to mess with this, maybe don't? I don't
    see why you would need to, as of now'


    Parameters
    ----------
    t : t
        Time argument. 
    p : vector
        initial state rho of the system.
    Rdic : Numpy Array
        Rate matrix dictionary from floquet_rate_matrix.
    beatfreq : float
        frequency dependance of the system.

    Returns
    -------
    ivp : Numpy Array? Not sure
        The ivp for the problem at hand. 

    '''
    Hdim = np.shape(p)[0]
    R = np.zeros((Hdim,Hdim),dtype=complex)
    for idx, targ in enumerate(Rdic.keys()):
        R += Rdic[targ]*np.exp(-1j*targ* (beatfreq/2)*t)
    ivp = (R)@p
    
    return ivp





'''
Misc functions that I don't wanna catagorize rn
'''


def freqarray(T,Nt,tau):   
    '''
    Parameters
    ----------
    T : float
        Time period of the Hamiltonian T.
    Nt : Float?
        Number of evenly space points in one time period of the Hamiltonian. Should probnably be a power of 2?
    tau : doesn't have to be int, but should probably be a whole number
        number of periods of evolution being sumlated.

    Returns
    -------
    oemga_array, the frequency array of the corresponding time-evolution

    '''    
    ############### Finding the fgrequency array over which to plot time evolution results #########################
    Ntau = int((Nt)*(tau))                                    
    taume = ((Ntau)/Nt)*T                             
    dtau = taume/(Ntau)                                 
                                                                                                
    omega_array = np.fft.fftshift(np.fft.fftfreq(Ntau,dtau))
    
    # omega_array1 = np.fft.fftfreq(Ntau,dtau)
    # omega_array = np.fft.fftshift(omega_array1)
    
    return omega_array


def mat(i,j):
    """
    Creates a matrix operator |i><j|

    Parameters
    ----------
    i : int
        ket state
    i : int
        bra stat

    Returns
    -------
    operator |i><j|

    """    
    return(basis(2,i)*basis(2,j).dag())


'''
Defining a kronecker delta function for later use
This will take the input matrix elements a,b, and return 1 if a=b, 0 else
'''
def kron(a,b):
    """
    Defining a matrix Kronecker Delta function
    This is really only used in the MEtensor function but might be useful later.

    Parameters
    ----------
    a : int
        matrix element a
    b : int
        matrix element b

    Returns
    -------
    0 if a!=b 
    1 if a=b

    """    
    if a == b:
        value = 1
    else:
        value = 0
    return value




def reorder(M,state0mat = None):
    '''
    Reorders the vectors of the input matrix into the order that best dots
        with the identity matrix (or state0mat if state0mat != None)

    Parameters
    ----------
    M : 2D Numpy array
        Input matrix to reorder.
    state0mat : 2d numpy array, optional
        If None, reorder M according to the identy matrix. If not None,
        reorder M according to state0mat. The default is None.

    Returns
    -------
    None.

    '''
    
    Mperms = [M[:,i] for i in list(itertools.permutations(range(0,shape(M)[0]),shape(M)[0]))] #Getting every permutation of the input matrix
    
    #The below line does the column-wise dot product of each permutation of the basis vectors with the identity matrix (the matrix form of the "computational basis" vectors)
    #First each column is multiplied elementwise, then the result of each product is summed to get the dot product for the row
    #Then, the absolute square is taken and this is added for the result of every column dot product in the "matrix column dot product thingy"
    #The permutation with the maximum result is the correct transformation matrix
    if state0mat == None:
        dots = [sum([abs(np.dot(Mperm[:,i],np.identity(np.shape(M)[1])[i]))**2 for i in range(np.shape(M)[1])]) for Mperm in Mperms]
    else:
        dots = [sum([abs(np.dot(Mperm[:,i],state0mat[i])) for i in range(np.shape(M)[1])]) for Mperm in Mperms]
    
    CorrPerm = np.where(dots == np.amax(dots))[0][0]
    v = M[:,list(itertools.permutations(range(0,shape(M)[0]),shape(M)[0]))[CorrPerm]]
    # v = np.sqrt(1/2)*np.array([[1,1,0,0],[1,-1,0,0],[0,0,1,1],[0,0,1,-1]])
        


   
    return v, list(itertools.permutations(range(0,shape(M)[0]),shape(M)[0]))[CorrPerm]

def lowop_detpol_modifier(lowop,dipoles,detpols):
    '''
    

    Parameters
    ----------
    lowop : numpy array
        Lowering operator for the quantum system.
    dipoles : Dictionary
        Dictionary of N {states linked:polarization} entries, with one key:value pair per
            dipole element.
    detpols : list
        List of desired detection polarizations.

    Returns
    -------
    lowlist : list
        List of matrices. Each matrix is the lowering operator(s) of the system
            under the desired detection polarization.

    '''
    detpoldic = {
    'X' : np.array([1,0,0]),
    'Y' : np.array([0,1,0]),
    'D' : (1/np.sqrt(2))*np.array([1,1,0]),
    'SP' :(1/np.sqrt(2))*np.array([1,1j,0]),
    'SM' :(1/np.sqrt(2))*np.array([1,-1j,0]),
    'NP' : np.array([None,None,None])}


    pollist = list([detpoldic[i] for i in detpols])


    lowlist = []
    for detpol in pollist:
        if detpol.any() != None:
            Lowp = lowop.full()
            for key in dipoles:
                if Lowp[key] != 0:
                    if np.dot(dipoles[key],detpol) != 0:
                       Lowp[key] = np.dot(dipoles[key],detpol)
                    else:
                        # print('this should not have happened')
                        Lowp[key] *= 0
            Lowp = Qobj(Lowp)  
            lowlist.append(Lowp)
        else:
            Lowp = lowop.full()
            for key in dipoles:
                if lowop[key] != 0:
                    Lowp[key] = np.dot(dipoles[key],detpoldic['X'])+np.dot(dipoles[key],detpoldic['Y'])
            Lowp = Qobj(Lowp) 
            lowlist.append(Lowp)
    return lowlist


